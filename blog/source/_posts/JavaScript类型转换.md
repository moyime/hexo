## 对象转换成原始值

* **对象转换成布尔值**：所有对象转换成布尔值都是true，包括包装对象new Boolean(false)转换成布尔值也是true。

* **对象转换成字符串**：如果对象有toString()方法，则调用这个方法，如果它返回原始值，将原始值转换成字符串后返回；如果对象没有toString()方法或调用toString()方法方法返回的不是原始值，则调用valueOf()方法，然后将valueOf()方法返回的原始值转换成字符串返回，如果valueOf()方法返回的还不是原始值，没救了，浏览器只好抛出类型异常的错误。
    ```
    let obj1={}
    let obj2={a:1,b:"b"}
    obj1.toString()  //"[object Object]"
    obj2.toString()  //"[object Object]"
    // obj1和obj2调用toString()转化为字符串都是 "[object Object]"
    ```

* **对象转换成数字**：和对象转换成字符串过程类似，只不过先调的是valueOf()方法。
    ```
    //1、调用valueOf()无法返回原始值  
    //2、后调用toString() 返回"[object Object]" 
    //3、"[object Object]" 转化为数值为NaN
    ```

## 隐式类型转换
* 如果一个值是null，另一个是undefined，那么它们相等
```
    null==undefined; //true
```
* 如果一个值是数字，另一个是字符串，先将字符串转为数字再比较
```
    "098"<"90"; //true;
    "098"<90; //false
```
* 如果其中一个值是true，将true转为1再比较，同理false转换成0再比较
```
    true<9;  //true
    true<"9";  //true
    true<"0";  //false
```
* 如果一个值是对象，另一个是数字或字符串，则将对象转换成原始值再进行比较（日期对象转换成字符串，其它对象先尝试调用valueOf()方法再尝试使用toString()）
* 其它不同类型的比较都不相等

诸如==、+、-、*、/、！、<、<=、>、>=等运算符两边的操作数类型不同时，都会发生隐式类型转换，还包括while()语句和if()语句内的条件语句，alert()语句会将()内的值隐式转换成字符串后再弹出。

## "+"运算符
### 二元加法运算符“+”可以对两个数字做加法，也可以做字符串连接操作
```
    1 + 1  // 2
    "hello" + "world"  // "hello world"
```
隐式转换规则：
* 如果其中一个操作数是对象，对象会转换成原始值：日期对象通过toString()方法转换，其他对象通过valueOf()方法转换，如果valueOf()返回值不是原始值再使用toString()方法转换。
* 在进行了对象到原始值的转换后，如果其中**一个操作数是字符串**的话，另一个操作数也会转换为字符串，然后进行字符串拼接。
* 否则，两个操作数都将转换为数字（转换不了的将转换为NaN），然后进行加法操作
```
    1+true;  //2
    "1"+true;  //"1true"
    1 + "1"  //"11"

    let obj={};
    obj+1  //  "[object Object]1"  obj对象调用toString()方法转换为字符串"[object Object]"
    obj+obj  // "[object Object][object Object]"
```
### 当“+”做为一元运算符时，会把操作数转换为数字（转不了的转成NaN）

实践：
```
//1、[]调用valueOf()后返回值不是原始值,
//2、调用toString()返回"", 
//3、执行**[] + 1** 即为 ""+1  结果为"1"
+([] + 1) + [0]  //"10"

(++([[]][+[]])) + [+[]]  //"10"
//（1）(++([[]][+[]])) + [+[]]  //运算符权重判断，安利一下第四题下面的文章
//（2）(++([[]][0])) + [0]      // 16题中我们讲过+用来做类型转换Number([]) ===0
//（3）+([] + 1) + [0]            //[[]]数组的第0项就是[],++代表自增+1  注意这一步不是 (++[]) + [0] 这样是错误的  
//（4）+([] + 1) + [0]           // 前面+将"1"转成数字1 后边，+是拼接 "0" 所以是字符串"10"
```

## "-"运算符
* 当“-”做为二元运算符时，会把操作数转换为数字（转不了的转成NaN） 
```
   8-1  //7
   "8"-1  //7
   "8a"-1  //NaN
```
* 当“-”做为一元运算符时，会把操作数转换为数字（转不了的转成NaN），同时改变运算结果的符号
```
    -9  //9
    -"9"  //9
    -"9a"  //NaN
```

## 比较运算符（">"、">="、"<"、"<="）
比较操作符的操作数可能是任意类型，然而只有数字和字符串才能真正执行比较操作，因此其它类型的操作数都将进行类型转换，具体规则如下：

* 如果操作数为对象，那么这个对象将转换为原始值：日期对象通过toString()方法转换，其他对象通过valueOf()方法转换，如果valueOf()返回值不是原始值再使用toString()方法转换。
* 在对象转换为原始值后，如果**两个操作数都是字符串**，将依次比较每个字符串的Unicode大小。
* 在对象转换为原始值后，如果至少有一个操作数不是字符串，那么两个操作数都将转换为数字进行比较，如果其中某个操作数无法转换为数字，这个操作数将转换为NaN，比较结果为false。
```
    "096"<"90"  //true
    "096"<90   //false  "096"会先转换为数字96
    true=="9"  //false  至少有一个操作数不是字符串，则将两个操作数转为数字再进行比较  即1==9?
    "98"==98  //true
    true=="1"  //true
    "a"==true //false  至少有一个操作数不是字符串，则将两个操作数转为数字再进行比较 又因为"a"转为数字时为NaN,所以比较结果为false
```
## "*"、"/"、"%"
会把操作数转换为数字（转不了的转成NaN） 
## "!"
会把操作数转换为布尔值